## MVVM, VIPER, CleanSwift, TDD

Все альтернативные архитектурные паттерны решают одну задачу: это разделение кода на отдельные логические блоки. Для чего это вообще нужно? Такой код не требует больших трудозатрат на сопровождение. Любые изменения в коде не вешают всю систему целиком, если что то и ломается, то это происходит локально и не критично. Ошибки немногочисленны, а функциональность и гибкость — максимальны. И этих причин уже достаточно, что бы задуматься о выборе той или иной архитектуры, но есть еще одна очень важная причина — это тестирование. 

Тесты — это такой код, который дается в нагрузку к функциональному коду. И зачастую этого кода столько же, а то и больше, чем функционального. Поэтому чем проще методы и чем меньше обязанностей на них возложено, тем более проще написать для такого метода тест.

Тестирование поможет Вам найти большинство ошибок на ранней стадии написания проекта. Как показывает опыт: если у Вас возникают трудности при тестировании кода, тогда у Вас возникнут сложности с его поддержкой или отладкой. 

TDD — это подход к разработке, основанный на повторении очень коротких циклов. При этом в первую очередь пишется тест, а далее под этот тест пишется рабочий код. Именно в такой последовательности: тест - код. 

При таком подходе вы изначально определяете дизайн того, как будет написан код. При этом сам код получается более модульным, т.к. тесты должны быть маленькими и самодостаточными, соответственно и методы, подстраиваемые под эти тесты, тоже получаются маленькими. 

Если проект изначально написан без тестов, то впоследствии покрыть его тестами будет гораздо сложнее, чем если бы изначально был использован подход от обратного, т.к. писать тесты под готовые методы гораздо сложнее, чем подстраивать методы под тесты.

На курсе ["Архитектурные паттерны в iOS"][1] мы рассмотрим несколько архитектурных паттернов и подходов, которые преследуют одну цель — разделение задач. Они все достигают этой цели путем деления программного обеспечения на уровни. Каждая имеет хотя бы один уровень для бизнес-правил и еще один для пользовательского и системного интерфейсов.

Каждая из рассмотренных архитектур способствует созданию систем, обладающих следующими характеристиками:

- Независимость от фреймворков. Архитектура не зависит от наличия какой-либо библиотеки. Это позволяет рассматривать фреймворки, как инструменты, вместо того чтобы стараться втиснуть систему в их рамки.
- Простота тестирования. Бизнес-правила можно тестировать без пользовательского интерфейса, базы данных, веб-сервера и любых других внешних элементов.
- Независимость от пользовательского интерфейса. Пользовательский интерфейс можно легко изменять, не затрагивая остальную систему. 
- Независимость от базы данных. Вы можете без проблем сменить CoreData на Realm.
- Независимость от любых внешних агентов. Ваши бизнес-правила ничего не знают об интерфейсах, ведущих во внешний мир. 

[1]:	https://learnmetoo.info/courses/arhitekturnye-patterny-ios